// [AsmJit]
// Complete x86/x64 JIT and Remote Assembler for C++.
//
// [License]
// Zlib - See LICENSE.md file in the package.

// [Guard]
#ifndef _ASMJIT_BASE_HLSTREAM_H
#define _ASMJIT_BASE_HLSTREAM_H

#include "../build.h"
#if !defined(ASMJIT_DISABLE_COMPILER)

// [Dependencies - AsmJit]
#include "../base/assembler.h"
#include "../base/operand.h"

// TODO: Cannot depend on it.
#include "../base/compilerfunc.h"

// [Api-Begin]
#include "../apibegin.h"

namespace asmjit {

// ============================================================================
// [Forward Declarations]
// ============================================================================

struct Compiler;
struct VarData;
struct VarState;
struct VarMap;

struct HLInst;
struct HLJump;
struct HLLabel;
struct HLSentinel;

//! \addtogroup asmjit_base
//! \{

// ============================================================================
// [asmjit::HLNodeType]
// ============================================================================

//! Type of \ref HLNode.
ASMJIT_ENUM(HLNodeType) {
  //! Invalid node (internal, don't use).
  kHLNodeTypeNone = 0,

  // --------------------------------------------------------------------------
  // [Low-Level - Assembler / Compiler]
  // --------------------------------------------------------------------------

  //! Node is \ref HLInst or \ref HLJump.
  kHLNodeTypeInst,
  //! Node is \ref HLData.
  kHLNodeTypeData,
  //! Node is \ref HLAlign.
  kHLNodeTypeAlign,
  //! Node is \ref HLLabel.
  kHLNodeTypeLabel,
  //! Node is \ref HLComment.
  kHLNodeTypeComment,
  //! Node is \ref HLSentinel.
  kHLNodeTypeSentinel,

  // --------------------------------------------------------------------------
  // [High-Level - Compiler-Only]
  // --------------------------------------------------------------------------

  //! Node is \ref HLHint.
  kHLNodeTypeHint,
  //! Node is \ref HLFunc.
  kHLNodeTypeFunc,
  //! Node is \ref HLRet.
  kHLNodeTypeRet,
  //! Node is \ref HLCall.
  kHLNodeTypeCall,
  //! Node is \ref HLCallArg.
  kHLNodeTypeCallArg
};

// ============================================================================
// [asmjit::HLNodeFlags]
// ============================================================================

ASMJIT_ENUM(HLNodeFlags) {
  //! Whether the node has been translated, thus contains only registers.
  kHLNodeFlagIsTranslated = 0x0001,

  //! Whether the node was scheduled - possibly reordered, but basically this
  //! is a mark that is set by scheduler after the node has been visited.
  kHLNodeFlagIsScheduled = 0x0002,

  //! Whether the node is informative only and can be safely removed.
  kHLNodeFlagIsInformative = 0x0004,

  //! Whether the `HLInst` is a jump.
  kHLNodeFlagIsJmp = 0x0008,
  //! Whether the `HLInst` is a conditional jump.
  kHLNodeFlagIsJcc = 0x0010,

  //! Whether the `HLInst` is an unconditinal jump or conditional jump that is
  //! likely to be taken.
  kHLNodeFlagIsTaken = 0x0020,

  //! Whether the `HLNode` will return from a function.
  //!
  //! This flag is used by both `HLSentinel` and `HLRet`.
  kHLNodeFlagIsRet = 0x0040,

  //! Whether the instruction is special.
  kHLNodeFlagIsSpecial = 0x0080,

  //! Whether the instruction is an FPU instruction.
  kHLNodeFlagIsFp = 0x0100
};

// ============================================================================
// [asmjit::HLNode]
// ============================================================================

//! Assembler stream (AS) node.
//!
//! Every node represents an abstract instruction, directive, label, or
//! macro-instruction generated by the `Compiler` or other code generator.
struct HLNode {
  ASMJIT_NO_COPY(HLNode)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLNode`.
  //!
  //! \note Always use compiler to create nodes.
  ASMJIT_INLINE HLNode(Compiler* compiler, uint32_t type); // Defined-Later.

  //! Destroy the `HLNode`.
  //!
  //! NOTE: Nodes are zone allocated, there should be no code in the destructor.
  ASMJIT_INLINE ~HLNode() {}

  // --------------------------------------------------------------------------
  // [Accessors - List]
  // --------------------------------------------------------------------------

  //! Get previous node in the compiler stream.
  ASMJIT_INLINE HLNode* getPrev() const { return _prev; }
  //! Get next node in the compiler stream.
  ASMJIT_INLINE HLNode* getNext() const { return _next; }

  // --------------------------------------------------------------------------
  // [Accessors - Comment]
  // --------------------------------------------------------------------------

  //! Get an inline comment string.
  ASMJIT_INLINE const char* getComment() const { return _comment; }
  //! Set an inline comment string to `comment`.
  ASMJIT_INLINE void setComment(const char* comment) { _comment = comment; }

  // --------------------------------------------------------------------------
  // [Accessors - Type and Flags]
  // --------------------------------------------------------------------------

  //! Get the node type, see \ref HLNodeType.
  ASMJIT_INLINE uint32_t getType() const { return _type; }
  //! Get the node flags.
  ASMJIT_INLINE uint32_t getFlags() const { return _flags; }

  //! Get whether the instruction has flag `flag`.
  ASMJIT_INLINE bool hasFlag(uint32_t flag) const { return (static_cast<uint32_t>(_flags) & flag) != 0; }
  //! Set node flags to `flags`.
  ASMJIT_INLINE void setFlags(uint32_t flags) { _flags = static_cast<uint16_t>(flags); }
  //! Add instruction `flags`.
  ASMJIT_INLINE void orFlags(uint32_t flags) { _flags |= static_cast<uint16_t>(flags); }
  //! And instruction `flags`.
  ASMJIT_INLINE void andFlags(uint32_t flags) { _flags &= static_cast<uint16_t>(flags); }
  //! Clear instruction `flags`.
  ASMJIT_INLINE void andNotFlags(uint32_t flags) { _flags &= ~static_cast<uint16_t>(flags); }

  //! Get whether the node has beed fetched.
  ASMJIT_INLINE bool isFetched() const { return _flowId != 0; }
  //! Get whether the node has been translated.
  ASMJIT_INLINE bool isTranslated() const { return hasFlag(kHLNodeFlagIsTranslated); }
  //! Get whether the node has been translated.
  ASMJIT_INLINE bool isScheduled() const { return hasFlag(kHLNodeFlagIsScheduled); }
  //! Get whether the node is informative only (comment, hint).
  ASMJIT_INLINE bool isInformative() const { return hasFlag(kHLNodeFlagIsInformative); }

  //! Whether the `HLInst` node is an unconditional jump.
  ASMJIT_INLINE bool isJmp() const { return hasFlag(kHLNodeFlagIsJmp); }
  //! Whether the `HLInst` node is a conditional jump.
  ASMJIT_INLINE bool isJcc() const { return hasFlag(kHLNodeFlagIsJcc); }
  //! Whether the `HLInst` node is a conditional/unconditional jump.
  ASMJIT_INLINE bool isJmpOrJcc() const { return hasFlag(kHLNodeFlagIsJmp | kHLNodeFlagIsJcc); }
  //! Whether the `HLInst` node is a return.
  ASMJIT_INLINE bool isRet() const { return hasFlag(kHLNodeFlagIsRet); }

  //! Get whether the node is `HLInst` and the instruction is special.
  ASMJIT_INLINE bool isSpecial() const { return hasFlag(kHLNodeFlagIsSpecial); }
  //! Get whether the node is `HLInst` and the instruction uses x87-FPU.
  ASMJIT_INLINE bool isFp() const { return hasFlag(kHLNodeFlagIsFp); }

  // --------------------------------------------------------------------------
  // [Accessors - FlowId]
  // --------------------------------------------------------------------------

  //! Get flow index.
  ASMJIT_INLINE uint32_t getFlowId() const { return _flowId; }
  //! Set flow index.
  ASMJIT_INLINE void setFlowId(uint32_t flowId) { _flowId = flowId; }

  // --------------------------------------------------------------------------
  // [Accessors - TokenId]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE bool hasTokenId(uint32_t id) const { return _tokenId == id; }
  ASMJIT_INLINE uint32_t getTokenId() const { return _tokenId; }
  ASMJIT_INLINE void setTokenId(uint32_t id) { _tokenId = id; }

  // --------------------------------------------------------------------------
  // [Accessors - VarMap]
  // --------------------------------------------------------------------------

  //! Get whether node contains variable allocation instructions.
  ASMJIT_INLINE bool hasMap() const { return _map != NULL; }
  //! Get variable allocation instructions.
  ASMJIT_INLINE VarMap* getMap() const { return _map; }
  //! Get variable allocation instructions casted to `T*`.
  template<typename T>
  ASMJIT_INLINE T* getMap() const { return static_cast<T*>(_map); }
  //! Set variable allocation instructions.
  ASMJIT_INLINE void setMap(VarMap* map) { _map = map; }

  // --------------------------------------------------------------------------
  // [Accessors - VarState]
  // --------------------------------------------------------------------------

  //! Get whether the node has an associated `VarState`.
  ASMJIT_INLINE bool hasState() const { return _state != NULL; }
  //! Get node state.
  ASMJIT_INLINE VarState* getState() const { return _state; }
  //! Get node state casted to `T*`.
  template<typename T>
  ASMJIT_INLINE T* getState() const { return static_cast<T*>(_state); }
  //! Set node state.
  ASMJIT_INLINE void setState(VarState* state) { _state = state; }

  // --------------------------------------------------------------------------
  // [Accessors - Liveness]
  // --------------------------------------------------------------------------

  //! Get whether the node has variable liveness bits.
  ASMJIT_INLINE bool hasLiveness() const { return _liveness != NULL; }
  //! Get variable liveness bits.
  ASMJIT_INLINE BitArray* getLiveness() const { return _liveness; }
  //! Set variable liveness bits.
  ASMJIT_INLINE void setLiveness(BitArray* liveness) { _liveness = liveness; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Previous node.
  HLNode* _prev;
  //! Next node.
  HLNode* _next;

  //! Node type, see \ref HLNodeType.
  uint8_t _type;
  //! Count of operands (if the node has operands, otherwise zero).
  uint8_t _opCount;
  //! Node flags, different meaning for every type of the node.
  uint16_t _flags;

  //! Flow index.
  uint32_t _flowId;

  //! Processing token ID.
  //!
  //! Used by some algorithms to mark nodes as visited. If the token is
  //! generated in an incrementing way the visitor can just mark nodes it
  //! visits and them compare the `HLNode`s token with it's local token.
  //! If they match the node has been visited already. Then the visitor
  //! doesn't need to clean things up as the next time the token will be
  //! different.
  uint32_t _tokenId;

  // TODO: 32-bit gap

  //! Inline comment string, initially set to NULL.
  const char* _comment;

  //! Variable mapping (VarAttr to VarData), initially NULL, filled during
  //! fetch phase.
  VarMap* _map;

  //! Variable liveness bits (initially NULL, filled by analysis phase).
  BitArray* _liveness;

  //! Saved state.
  //!
  //! Initially NULL, not all nodes have saved state, only branch/flow control
  //! nodes.
  VarState* _state;
};

// ============================================================================
// [asmjit::HLInst]
// ============================================================================

//! Instruction node (HL).
//!
//! Wraps an instruction with its options and operands.
struct HLInst : public HLNode {
  ASMJIT_NO_COPY(HLInst)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLInst` instance.
  ASMJIT_INLINE HLInst(Compiler* compiler, uint32_t instId, uint32_t instOptions, Operand* opList, uint32_t opCount)
    : HLNode(compiler, kHLNodeTypeInst) {

    _instId = static_cast<uint16_t>(instId);
    _reserved = 0;
    _instOptions = instOptions;

    _opCount = static_cast<uint8_t>(opCount);
    _opList = opList;

    _updateMemOp();
  }

  //! Destroy the `HLInst` instance.
  ASMJIT_INLINE ~HLInst() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the instruction id, see `X86InstId`.
  ASMJIT_INLINE uint32_t getInstId() const { return _instId; }
  //! Set the instruction id to `instId`.
  //!
  //! NOTE: Please do not modify instruction code if you don't know what you
  //! are doing. Incorrect instruction code and/or operands can cause random
  //! errors in production builds and will most probably trigger assertion
  //! failures in debug builds.
  ASMJIT_INLINE void setInstId(uint32_t instId) { _instId = static_cast<uint16_t>(instId); }

  //! Whether the instruction is either a jump or a conditional jump likely to
  //! be taken.
  ASMJIT_INLINE bool isTaken() const { return hasFlag(kHLNodeFlagIsTaken); }

  //! Get emit options.
  ASMJIT_INLINE uint32_t getOptions() const { return _instOptions; }
  //! Set emit options.
  ASMJIT_INLINE void setOptions(uint32_t options) { _instOptions = options; }
  //! Add emit options.
  ASMJIT_INLINE void addOptions(uint32_t options) { _instOptions |= options; }
  //! Mask emit options.
  ASMJIT_INLINE void andOptions(uint32_t options) { _instOptions &= options; }
  //! Clear emit options.
  ASMJIT_INLINE void delOptions(uint32_t options) { _instOptions &= ~options; }

  //! Get operands count.
  ASMJIT_INLINE uint32_t getOpCount() const { return _opCount; }
  //! Get operands list.
  ASMJIT_INLINE Operand* getOpList() { return _opList; }
  //! \overload
  ASMJIT_INLINE const Operand* getOpList() const { return _opList; }

  //! Get whether the instruction contains a memory operand.
  ASMJIT_INLINE bool hasMemOp() const { return _memOpIndex != 0xFF; }
  //! Get memory operand.
  //!
  //! NOTE: Can only be called if the instruction has such operand,
  //! see `hasMemOp()`.
  ASMJIT_INLINE BaseMem* getMemOp() const {
    ASMJIT_ASSERT(hasMemOp());
    return static_cast<BaseMem*>(&_opList[_memOpIndex]);
  }
  //! \overload
  template<typename T>
  ASMJIT_INLINE T* getMemOp() const {
    ASMJIT_ASSERT(hasMemOp());
    return static_cast<T*>(&_opList[_memOpIndex]);
  }

  //! Set memory operand index, `0xFF` means no memory operand.
  ASMJIT_INLINE void setMemOpIndex(uint32_t index) { _memOpIndex = static_cast<uint8_t>(index); }
  //! Reset memory operand index to `0xFF` (no operand).
  ASMJIT_INLINE void resetMemOpIndex() { _memOpIndex = 0xFF; }

  // --------------------------------------------------------------------------
  // [Utils]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE void _updateMemOp() {
    Operand* opList = getOpList();
    uint32_t opCount = getOpCount();

    uint32_t i;
    for (i = 0; i < opCount; i++)
      if (opList[i].isMem())
        goto _Update;
    i = 0xFF;

_Update:
    setMemOpIndex(i);
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Instruction ID, see `InstId`.
  uint16_t _instId;
  //! \internal
  uint8_t _memOpIndex;
  //! \internal
  uint8_t _reserved;
  //! Instruction options, see `InstOptions`.
  uint32_t _instOptions;

  //! Operands list.
  Operand* _opList;
};

// ============================================================================
// [asmjit::HLJump]
// ============================================================================

//! Jump node (HL).
//!
//! Extension of `HLInst` node, which stores more information about the jump.
struct HLJump : public HLInst {
  ASMJIT_NO_COPY(HLJump)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE HLJump(Compiler* compiler, uint32_t code, uint32_t options, Operand* opList, uint32_t opCount) :
    HLInst(compiler, code, options, opList, opCount) {}
  ASMJIT_INLINE ~HLJump() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  ASMJIT_INLINE HLLabel* getTarget() const { return _target; }
  ASMJIT_INLINE HLJump* getJumpNext() const { return _jumpNext; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Target node.
  HLLabel* _target;
  //! Next jump to the same target in a single linked-list.
  HLJump* _jumpNext;
};

// ============================================================================
// [asmjit::HLData]
// ============================================================================

//! Data node (HL).
//!
//! Wraps `.data` directive. The node contains data that will be placed at the
//! node's position in the assembler stream. The data is considered to be RAW;
//! no analysis nor byte-order conversion is performed on RAW data.
struct HLData : public HLNode {
  ASMJIT_NO_COPY(HLData)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  enum { kInlineBufferSize = 12 };

  //! Create a new `HLData` instance.
  ASMJIT_INLINE HLData(Compiler* compiler, void* data, uint32_t size)
    : HLNode(compiler, kHLNodeTypeData) {

    _size = size;
    if (size <= kInlineBufferSize) {
      if (data != NULL)
        ::memcpy(_data.buf, data, size);
    }
    else {
      _data.ptr = static_cast<uint8_t*>(data);
    }
  }

  //! Destroy the `HLData` instance.
  ASMJIT_INLINE ~HLData() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get size of the data.
  uint32_t getSize() const { return _size; }
  //! Get pointer to the data.
  uint8_t* getData() const { return _size <= kInlineBufferSize ? const_cast<uint8_t*>(_data.buf) : _data.ptr; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  union {
    //! data buffer.
    uint8_t buf[kInlineBufferSize];
    //! Data buffer.
    uint8_t* ptr;
  } _data;

  //! Size of the data.
  uint32_t _size;
};

// ============================================================================
// [asmjit::HLAlign]
// ============================================================================

//! Align node (HL).
//!
//! Wraps `.align` directive.
struct HLAlign : public HLNode {
  ASMJIT_NO_COPY(HLAlign)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLAlign` instance.
  ASMJIT_INLINE HLAlign(Compiler* compiler, uint32_t alignMode, uint32_t offset)
    : HLNode(compiler, kHLNodeTypeAlign) {

    _alignMode = alignMode;
    _offset = offset;
  }

  //! Destroy the `HLAlign` instance.
  ASMJIT_INLINE ~HLAlign() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get align mode.
  ASMJIT_INLINE uint32_t getAlignMode() const { return _alignMode; }
  //! Set align mode.
  ASMJIT_INLINE void setAlignMode(uint32_t alignMode) { _alignMode = alignMode; }

  //! Get align offset in bytes.
  ASMJIT_INLINE uint32_t getOffset() const { return _offset; }
  //! Set align offset in bytes to `offset`.
  ASMJIT_INLINE void setOffset(uint32_t offset) { _offset = offset; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Align mode, see \ref AlignMode.
  uint32_t _alignMode;
  //! Align offset (in bytes).
  uint32_t _offset;
};

// ============================================================================
// [asmjit::HLLabel]
// ============================================================================

//! label node (HL).
struct HLLabel : public HLNode {
  ASMJIT_NO_COPY(HLLabel)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLLabel` instance.
  ASMJIT_INLINE HLLabel(Compiler* compiler, uint32_t labelId)
    : HLNode(compiler, kHLNodeTypeLabel) {

    _id = labelId;
    _numRefs = 0;
    _from = NULL;
  }

  //! Destroy the `HLLabel` instance.
  ASMJIT_INLINE ~HLLabel() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get target label.
  ASMJIT_INLINE Label getLabel() const { return Label(_id); }
  //! Get target label id.
  ASMJIT_INLINE uint32_t getLabelId() const { return _id; }

  //! Get first jmp instruction.
  ASMJIT_INLINE HLJump* getFrom() const { return _from; }

  //! Get whether the node has assigned state.
  ASMJIT_INLINE bool hasState() const { return _state != NULL; }
  //! Get state for this target.
  ASMJIT_INLINE VarState* getState() const { return _state; }
  //! Set state for this target.
  ASMJIT_INLINE void setState(VarState* state) { _state = state; }

  //! Get number of jumps to this target.
  ASMJIT_INLINE uint32_t getNumRefs() const { return _numRefs; }
  //! Set number of jumps to this target.
  ASMJIT_INLINE void setNumRefs(uint32_t i) { _numRefs = i; }

  //! Add number of jumps to this target.
  ASMJIT_INLINE void addNumRefs(uint32_t i = 1) { _numRefs += i; }
  //! Subtract number of jumps to this target.
  ASMJIT_INLINE void subNumRefs(uint32_t i = 1) { _numRefs -= i; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Label id.
  uint32_t _id;
  //! Count of jumps here.
  uint32_t _numRefs;

  //! First jump instruction that points to this target (label).
  HLJump* _from;
};

// ============================================================================
// [asmjit::HLComment]
// ============================================================================

//! Comment node (HL).
struct HLComment : public HLNode {
  ASMJIT_NO_COPY(HLComment)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLComment` instance.
  ASMJIT_INLINE HLComment(Compiler* compiler, const char* comment)
    : HLNode(compiler, kHLNodeTypeComment) {

    orFlags(kHLNodeFlagIsInformative);
    _comment = comment;
  }

  //! Destroy the `HLComment` instance.
  ASMJIT_INLINE ~HLComment() {}
};

// ============================================================================
// [asmjit::HLSentinel]
// ============================================================================

//! Sentinel node (HL).
struct HLSentinel : public HLNode {
  ASMJIT_NO_COPY(HLSentinel)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLSentinel` instance.
  ASMJIT_INLINE HLSentinel(Compiler* compiler)
    : HLNode(compiler, kHLNodeTypeSentinel) {
    _flags |= kHLNodeFlagIsRet;
  }

  //! Destroy the `HLSentinel` instance.
  ASMJIT_INLINE ~HLSentinel() {}
};

// ============================================================================
// [asmjit::HLHint]
// ============================================================================

//! Hint node.
struct HLHint : public HLNode {
  ASMJIT_NO_COPY(HLHint)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLHint` instance.
  ASMJIT_INLINE HLHint(Compiler* compiler, VarData* vd, uint32_t hint, uint32_t value)
    : HLNode(compiler, kHLNodeTypeHint) {

    orFlags(kHLNodeFlagIsInformative);
    _vd = vd;
    _hint = hint;
    _value = value;
  }

  //! Destroy the `HLHint` instance.
  ASMJIT_INLINE ~HLHint() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get variable.
  ASMJIT_INLINE VarData* getVd() const { return _vd; }

  //! Get hint it (see `kVarHint)`.
  ASMJIT_INLINE uint32_t getHint() const{ return _hint; }
  //! Set hint it (see `kVarHint)`.
  ASMJIT_INLINE void setHint(uint32_t hint) { _hint = hint; }

  //! Get hint value.
  ASMJIT_INLINE uint32_t getValue() const { return _value; }
  //! Set hint value.
  ASMJIT_INLINE void setValue(uint32_t value) { _value = value; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Variable.
  VarData* _vd;
  //! Hint id.
  uint32_t _hint;
  //! Value.
  uint32_t _value;
};

// ============================================================================
// [asmjit::HLFunc]
// ============================================================================

//! Function node (HL).
struct HLFunc : public HLNode {
  ASMJIT_NO_COPY(HLFunc)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLFunc` instance.
  //!
  //! Always use `Compiler::addFunc()` to create an `HLFunc` instance.
  ASMJIT_INLINE HLFunc(Compiler* compiler)
    : HLNode(compiler, kHLNodeTypeFunc),
      _entryNode(NULL),
      _exitNode(NULL),
      _decl(NULL),
      _end(NULL),
      _args(NULL),
      _funcHints(Utils::mask(kFuncHintNaked)),
      _funcFlags(0),
      _expectedStackAlignment(0),
      _requiredStackAlignment(0),
      _redZoneSize(0),
      _spillZoneSize(0),
      _argStackSize(0),
      _memStackSize(0),
      _callStackSize(0) {}

  //! Destroy the `HLFunc` instance.
  ASMJIT_INLINE ~HLFunc() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get function entry `HLLabel`.
  ASMJIT_INLINE HLLabel* getEntryNode() const { return _entryNode; }
  //! Get function exit `HLLabel`.
  ASMJIT_INLINE HLLabel* getExitNode() const { return _exitNode; }

  //! Get function entry label.
  ASMJIT_INLINE Label getEntryLabel() const { return _entryNode->getLabel(); }
  //! Get function exit label.
  ASMJIT_INLINE Label getExitLabel() const { return _exitNode->getLabel(); }

  //! Get the function end sentinel.
  ASMJIT_INLINE HLSentinel* getEnd() const { return _end; }
  //! Get function declaration.
  ASMJIT_INLINE FuncDecl* getDecl() const { return _decl; }

  //! Get arguments count.
  ASMJIT_INLINE uint32_t getNumArgs() const { return _decl->getNumArgs(); }
  //! Get arguments list.
  ASMJIT_INLINE VarData** getArgs() const { return _args; }

  //! Get argument at `i`.
  ASMJIT_INLINE VarData* getArg(uint32_t i) const {
    ASMJIT_ASSERT(i < getNumArgs());
    return _args[i];
  }

  //! Set argument at `i`.
  ASMJIT_INLINE void setArg(uint32_t i, VarData* vd) {
    ASMJIT_ASSERT(i < getNumArgs());
    _args[i] = vd;
  }

  //! Reset argument at `i`.
  ASMJIT_INLINE void resetArg(uint32_t i) {
    ASMJIT_ASSERT(i < getNumArgs());
    _args[i] = NULL;
  }

  //! Get function hints.
  ASMJIT_INLINE uint32_t getFuncHints() const { return _funcHints; }
  //! Get function flags.
  ASMJIT_INLINE uint32_t getFuncFlags() const { return _funcFlags; }

  //! Get whether the _funcFlags has `flag`
  ASMJIT_INLINE bool hasFuncFlag(uint32_t flag) const { return (_funcFlags & flag) != 0; }
  //! Set function `flag`.
  ASMJIT_INLINE void addFuncFlags(uint32_t flags) { _funcFlags |= flags; }
  //! Clear function `flag`.
  ASMJIT_INLINE void clearFuncFlags(uint32_t flags) { _funcFlags &= ~flags; }

  //! Get whether the function is naked.
  ASMJIT_INLINE bool isNaked() const { return hasFuncFlag(kFuncFlagIsNaked); }
  //! Get whether the function is also a caller.
  ASMJIT_INLINE bool isCaller() const { return hasFuncFlag(kFuncFlagIsCaller); }
  //! Get whether the required stack alignment is lower than expected one,
  //! thus it has to be aligned manually.
  ASMJIT_INLINE bool isStackMisaligned() const { return hasFuncFlag(kFuncFlagIsStackMisaligned); }
  //! Get whether the stack pointer is adjusted inside function prolog/epilog.
  ASMJIT_INLINE bool isStackAdjusted() const { return hasFuncFlag(kFuncFlagIsStackAdjusted); }

  //! Get whether the function is finished.
  ASMJIT_INLINE bool isFinished() const { return hasFuncFlag(kFuncFlagIsFinished); }

  //! Get expected stack alignment.
  ASMJIT_INLINE uint32_t getExpectedStackAlignment() const { return _expectedStackAlignment; }
  //! Set expected stack alignment.
  ASMJIT_INLINE void setExpectedStackAlignment(uint32_t alignment) { _expectedStackAlignment = alignment; }

  //! Get required stack alignment.
  ASMJIT_INLINE uint32_t getRequiredStackAlignment() const { return _requiredStackAlignment; }
  //! Set required stack alignment.
  ASMJIT_INLINE void setRequiredStackAlignment(uint32_t alignment) { _requiredStackAlignment = alignment; }

  //! Update required stack alignment so it's not lower than expected
  //! stack alignment.
  ASMJIT_INLINE void updateRequiredStackAlignment() {
    if (_requiredStackAlignment <= _expectedStackAlignment) {
      _requiredStackAlignment = _expectedStackAlignment;
      clearFuncFlags(kFuncFlagIsStackMisaligned);
    }
    else {
      addFuncFlags(kFuncFlagIsStackMisaligned);
    }
  }

  //! Set stack "Red Zone" size.
  ASMJIT_INLINE uint32_t getRedZoneSize() const { return _redZoneSize; }
  //! Get stack "Red Zone" size.
  ASMJIT_INLINE void setRedZoneSize(uint32_t s) { _redZoneSize = static_cast<uint16_t>(s); }

  //! Set stack "Spill Zone" size.
  ASMJIT_INLINE uint32_t getSpillZoneSize() const { return _spillZoneSize; }
  //! Get stack "Spill Zone" size.
  ASMJIT_INLINE void setSpillZoneSize(uint32_t s) { _spillZoneSize = static_cast<uint16_t>(s); }

  //! Get stack size used by function arguments.
  ASMJIT_INLINE uint32_t getArgStackSize() const { return _argStackSize; }

  //! Get stack size used by variables and memory allocated on the stack.
  ASMJIT_INLINE uint32_t getMemStackSize() const { return _memStackSize; }

  //! Get stack size used by function calls.
  ASMJIT_INLINE uint32_t getCallStackSize() const { return _callStackSize; }
  //! Merge stack size used by function call with `s`.
  ASMJIT_INLINE void mergeCallStackSize(uint32_t s) { if (_callStackSize < s) _callStackSize = s; }

  // --------------------------------------------------------------------------
  // [Hints]
  // --------------------------------------------------------------------------

  //! Set function hint.
  ASMJIT_INLINE void setHint(uint32_t hint, uint32_t value) {
    ASMJIT_ASSERT(hint <= 31);
    ASMJIT_ASSERT(value <= 1);

    _funcHints &= ~(1     << hint);
    _funcHints |=  (value << hint);
  }

  //! Get function hint.
  ASMJIT_INLINE uint32_t getHint(uint32_t hint) const {
    ASMJIT_ASSERT(hint <= 31);
    return (_funcHints >> hint) & 0x1;
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Function entry.
  HLLabel* _entryNode;
  //! Function exit.
  HLLabel* _exitNode;

  //! Function declaration.
  FuncDecl* _decl;
  //! Function end.
  HLSentinel* _end;

  //! Arguments list as `VarData`.
  VarData** _args;

  //! Function hints;
  uint32_t _funcHints;
  //! Function flags.
  uint32_t _funcFlags;

  //! Expected stack alignment (we depend on this value).
  //!
  //! \note It can be global alignment given by the OS or described by the
  //! target platform ABI.
  uint32_t _expectedStackAlignment;
  //! Required stack alignment (required by SIMD instructions).
  uint32_t _requiredStackAlignment;

  //! The "Red Zone" size - count of bytes which might be accessed by a left
  //! function without adjusting the stack pointer (`esp` or `rsp`) (AMD64 ABI).
  uint16_t _redZoneSize;

  //! The "Spill Zone" size - count of bytes after the function return address
  //! that can be used by the function to spill variables in (WIN64 ABI).
  uint16_t _spillZoneSize;

  //! Stack size needed for function arguments.
  uint32_t _argStackSize;
  //! Stack size needed for all variables and memory allocated on the stack.
  uint32_t _memStackSize;
  //! Stack size needed to call other functions.
  uint32_t _callStackSize;
};

// ============================================================================
// [asmjit::HLRet]
// ============================================================================

//! Return node (HL).
struct HLRet : public HLNode {
  ASMJIT_NO_COPY(HLRet)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLRet` instance.
  ASMJIT_INLINE HLRet(Compiler* compiler, const Operand& o0, const Operand& o1)
    : HLNode(compiler, kHLNodeTypeRet) {

    _flags |= kHLNodeFlagIsRet;
    _ret[0] = o0;
    _ret[1] = o1;
  }

  //! Destroy the `HLRet` instance.
  ASMJIT_INLINE ~HLRet() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the first return operand.
  ASMJIT_INLINE Operand& getFirst() { return _ret[0]; }
  //! \overload
  ASMJIT_INLINE const Operand& getFirst() const { return _ret[0]; }

  //! Get the second return operand.
  ASMJIT_INLINE Operand& getSecond() { return _ret[1]; }
   //! \overload
  ASMJIT_INLINE const Operand& getSecond() const { return _ret[1]; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Ret operand(s).
  Operand _ret[2];
};

// ============================================================================
// [asmjit::HLCall]
// ============================================================================

//! Call node (HL).
struct HLCall : public HLNode {
  ASMJIT_NO_COPY(HLCall)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLCall` instance.
  ASMJIT_INLINE HLCall(Compiler* compiler, const Operand& target)
    : HLNode(compiler, kHLNodeTypeCall),
      _decl(NULL),
      _target(target),
      _args(NULL) {}

  //! Destroy the `HLCall` instance.
  ASMJIT_INLINE ~HLCall() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get function declaration.
  ASMJIT_INLINE FuncDecl* getDecl() const { return _decl; }

  //! Get target operand.
  ASMJIT_INLINE Operand& getTarget() { return _target; }
  //! \overload
  ASMJIT_INLINE const Operand& getTarget() const  { return _target; }

  //! Get return at `i`.
  ASMJIT_INLINE Operand& getRet(uint32_t i = 0) {
    ASMJIT_ASSERT(i < 2);
    return _ret[i];
  }
  //! \overload
  ASMJIT_INLINE const Operand& getRet(uint32_t i = 0) const  {
    ASMJIT_ASSERT(i < 2);
    return _ret[i];
  }

  //! Get argument at `i`.
  ASMJIT_INLINE Operand& getArg(uint32_t i) {
    ASMJIT_ASSERT(i < kFuncArgCountLoHi);
    return _args[i];
  }
  //! \overload
  ASMJIT_INLINE const Operand& getArg(uint32_t i) const  {
    ASMJIT_ASSERT(i < kFuncArgCountLoHi);
    return _args[i];
  }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Function declaration.
  FuncDecl* _decl;

  //! Target (address of function, register, label, ...).
  Operand _target;
  //! Return.
  Operand _ret[2];
  //! Arguments.
  Operand* _args;
};

// ============================================================================
// [asmjit::HLCallArg]
// ============================================================================

//! Function call's argument node (HL).
struct HLCallArg : public HLNode {
  ASMJIT_NO_COPY(HLCallArg)

  // --------------------------------------------------------------------------
  // [Construction / Destruction]
  // --------------------------------------------------------------------------

  //! Create a new `HLCallArg` instance.
  ASMJIT_INLINE HLCallArg(Compiler* compiler, HLCall* call, VarData* sVd, VarData* cVd)
    : HLNode(compiler, kHLNodeTypeCallArg),
      _call(call),
      _sVd(sVd),
      _cVd(cVd),
      _args(0) {}

  //! Destroy the `HLCallArg` instance.
  ASMJIT_INLINE ~HLCallArg() {}

  // --------------------------------------------------------------------------
  // [Accessors]
  // --------------------------------------------------------------------------

  //! Get the associated function-call.
  ASMJIT_INLINE HLCall* getCall() const { return _call; }
  //! Get source variable.
  ASMJIT_INLINE VarData* getSVd() const { return _sVd; }
  //! Get conversion variable.
  ASMJIT_INLINE VarData* getCVd() const { return _cVd; }

  // --------------------------------------------------------------------------
  // [Members]
  // --------------------------------------------------------------------------

  //! Associated `HLCall`.
  HLCall* _call;
  //! Source variable.
  VarData* _sVd;
  //! Temporary variable used for conversion (or NULL).
  VarData* _cVd;

  //! Affected arguments bit-array.
  uint32_t _args;
};

// ============================================================================
// [asmjit::Stream]
// ============================================================================



//! \}

} // asmjit namespace

// [Api-End]
#include "../apiend.h"

// [Guard]
#endif // !ASMJIT_DISABLE_COMPILER
#endif // _ASMJIT_BASE_HLSTREAM_H
