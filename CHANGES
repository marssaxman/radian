# next - not yet released

- Indexed lookup on a list object no longer fails for lists larger than a few
dozen items, where the internal finger tree splits off into multiple levels.

- Loops no longer continue to run when an assertion inside the loop fails.

- Real-number literals now accept an 'f' or 'F' suffix to indicate that they
are approximate numbers which should be represented as floats.

- New 'string.from_number' function accepts a number and a precision, then
returns a string representing the number's value to the specified precision,
in decimal, with a leading minus sign if necessary.

- Old 'string.from_number' function renamed 'string.from_integer', since it
ignores any fractional component of its input. It now accepts any radix from
2 up to 36 (old limit was 16).

- New 'math' module includes basic math functions 'max' and 'min', exponential
functions exp, sqrt, hypot, and pow, and trigonometric functions sin, cos, tan,
asin, acos, atan, atan2, sinh, cosh, tanh, asinh, acosh, and atanh.

- Number library has new function to_float(x) which converts any number to
the nearest floating-point approximation.

- New 'debug_trace' statement accepts one expression, a string, and prints it
to stderr. This is not an IO action and does not need to be sync'ed. This is
useful if you are trying to work out what a program is doing, and the code in
question does not happen to be in a context where you can sync io.print.

- Equals sign is now a legal trailing identifier character. This is the setter
method protocol: the statement 'foo->bar = baz' compiles into the equivalent of
'foo = foo.bar=(baz)'. Now you can write your own setter methods which are 
indistinguishable from the ones implicitly generated for 'var' members of
objects and modules, by writing a method which accepts one parameter and whose
name ends in an equals sign.

- Raising a number to a fractional exponent produces a new type of number, the
float, which is based on the 64-bit IEEE754 double. Any operation involving a
float and an integer or rational produces a float result; floats are inexact,
so any operation on a float is necessarily an approximation.

- Power operator works, no longer throwing a "not yet implemented" exception.

- Command line now organized around "subcommands", like git, mercurial, and go.
Execute 'radian help' for documentation.

- Lexer no longer accepts overlong UTF-8 sequences; they are now reported as
lexical errors.

- Restored induction variable hoisting in for-loops. This optimization extracts
parallelizable loop subexpressions from a loop body and maps them over the
input sequence, allowing the computation to be performed across multiple cores.

- Updated to libffi-3.0.13 and llvm-3.3. If you are set up to build Radian,
please re-run ./make-devenv.sh.

- string.decimal, string.hex, string.binary, and string.octal now put the minus
sign at the beginning of a negative number and not the end.

- string.decimal, string.hex, string.binary, and string.octal now return the
integer portion of a non-integral input number instead of locking up.

- Numeric operators no longer throw a spurious not-a-number exception when both
the left and right operands are rationals.

- Tuples throw an exception instead of failing an assertion when the lookup
index is not an integer.

- A more specific error message occurs when you accidentally use the arrow
operator inside an expression, since that would change an object as a side-
effect. Object modification must be a separate statement.

- ffi module offers 'bool' type.

- Looks for target-specific implementations of imported library files, using
the OS and architecture fields of the target triple. When importing a module
named "foo", first attempts to load foo-$OS-$ARCH.radian, then foo-$OS.radian,
then foo-$ARCH.radian, and finally the plain foo.radian. This allows a program
to either override a generic, cross-platform library with a version optimized
for a specific target, or to provide architecture- or OS-specific modules which
implement a common interface over some platform-specific behavior.

- string.to_upper and string.to_lower no longer return invalid strings.

- New string.fold_case function normalizes a string to the Unicode form used
for case-insensitive comparison.


# 0.7.0 - 24 April 2013

- Fixed a bug in the garbage collector copy-forwarding mechanism which caused
strange runtime library assertion failures after 'sync' statements.

- No longer misassigns a terminator byte when performing concatenations of
certain very short strings.

- 'const' statement renamed to 'def'. The semantics are the same; only the
keyword has changed. The statement never created a constant in the mathematical
sense; it simply defines a name for a value which cannot be redefined.

- Importing a file whose name begins with an underscore no longer fails, trying
to load a mangled version of the file name instead. While the compiler does not
enforce this convention, prepending a file name with an underscore is a way to
show that the file contains private implementation details and should not be
imported from outside the directory which contains it.

- No longer misprocesses hex character escapes inside string literals.

- More specific error message when you try to modify the 'self' object inside
a function and not a method.

- More helpful error message when an 'import' statement fails: now points at
the location of the import statement which failed. This might happen if you
typo the import name and accidentally specify a file which does not exist.

- Fixed a race condition in the parallel work dispatcher which sometimes caused
a null dereference crash.



# 0.6.0 - 10 October 2012

- No longer handles sync expressions in the 'predicate' term of a list
comprehension improperly; this could have led to a compiler crash.

- Former IO object method 'read_file' has been moved to the 'file' module and
renamed 'read_bytes', since its job is to read the file in as a byte buffer.
There is no longer a filespec object; just use a path string.

- ffi.load_external function no longer requires its arguments to be string
literals; it will now accept any string for the file path or function name.

- sync expression no longer returns incorrect value; it had been returning the
last IO action applied instead of the result of that action.

- Concatenating a string onto a string literal no longer fails when the right-
hand string is not also a string literal; it had been raising an assertion.

- Text encoding objects live in a new 'encoding' library; encodings convert
strings to and from byte streams. Encodings currently offered are ASCII, UTF-8,
and UTF-16 in its big- and little-endian variants.

- FFI library no longer includes specific types for each supported string
encoding: instead, there's a single ffi.string object which accepts a parameter
specifying the text encoding to use. 

- file.read_string is a new function which reads a whole file in as a string;
you specify the file path and the text encoding to use.

- string.length function computes the number of codepoints in a string.

- string.from_codepoint function creates a single-character string from an
integer codepoint value

- Line continuation after binops will now work outside of a function or other
indented block; it used to fail when used on a root-level statement.

- String concatenation algorithmic complexity is now amortized O(log N) on the
length of the composite string; it was previously O(n). Iteration time per
character is still approximately constant.

- string.is_empty function returns true if the string contains no characters.

- string.split_lines function breaks a single string into a sequence of lines,
separated by linebreak; the function accepts any of LF, CRLF, or CR as valid
line breaks. An empty file will produce an empty sequence, but characters left
on the end of the file with no trailing linebreak will be returned as their
own line.

- sequence.take function accepts a sequence and a number of elements, then
returns the first N elements of the sequence, or the whole sequence if it has
N or fewer elements. Corresponding string.take function returns the first N
characters of a string.

- sequence.drop function accepts a sequence and a number of elements, skips
the first N elements of the sequence, then returns the remaining sequence. A
corresponding string.drop function does the same job for characters in a string.

- sequence.singleton(X) function returns a one-element sequence consisting of
the specified value X. 

- sequence.replicate(X, N) function returns a sequence N elements long where
every value is equal to the specified X.

- sequence.length(seq) counts the number of elements in the sequence.

- assert statement evaluation is no longer deferred til after a sync: if the
assert fails, the sync will return an appropriate exception.

- string.slice(str, begin, length) returns a substring of length no greater
than the specified number of characters beginning at the specified number of 
chars after the beginning of the argument string. If 'begin' is equal to or
greater than the length of the string, slice will return an empty string.

- string.replicate(str, count) creates a string by repeating the argument a
specified number of times. If the count is zero or the string is empty, it will
return an empty string.

- set.union(a, b), set.intersection(a, b), and set.difference(a, b) implement
three of the four basic set operators (it remains to be seen whether there is a
practical implementation for complement).

- new queue module implements a queue data structure: append items to the tail
of the queue, then pop them from the head. The queue object also implements the
sequence interface, so you can iterate over a queue instead of using head/pop.

- io.write_file moved to 'file' module and renamed file.write_bytes. A related
file.write_string accepts an encoding parameter, allowing you to write a string
out as a text file.


# 0.5.0 - 9 September 2012

- dump switch now supports 'llvm' option, producing LLVM IR.

- IO system rewritten to use asynchronous tasks. IO methods no longer mutate
the implicit IO object, but simply return asynchronous task objects which you
can then 'sync' to execute. It is no longer necessary to pass in a separate
callback expression; the program will continue when task execution completes.

- Former IO object methods load_external, describe_function, and call have been
moved to the FFI ("foreign function interface") module.

- Number type predicates have been renamed from 'number?' to 'is_number',
'integer?' to 'is_integer', and 'rational?' to 'is_rational'.

- All 'type?' functions in the standard library have been renamed to 'type'.

- Question marks are no longer allowed as identifier and symbol suffixes. The
category "suffix character" no longer exists. An identifier may begin with any
character in the Unicode category XID_Start, or an underscore, and may continue
with any number of characters in the Unicode category XID_Continue.

- Methods of built-in objects check the number of incoming arguments and report
an appropriate exception when there are too many or too few. Previous behavior
was undefined.

- List member indexed lookup no longer dies with strange "member not found"
exception after the list grows larger than 8 items.

- A list, once reversed, can now concatenate another list without throwing an
"unimplemented" exception.

- Number module now offers a range_with_step function, accepting parameters
min, max, and step. Like the normal range function, this counts from min to max.
If step is positive, it continues while current <= max; if step is negative,
the sequence continues while current >= max.

- Sync operator no longer needs to be the root of its expression: you can now
use the result of the sync in a compound expression involving other values,
other function calls, and even other syncs. Expressions are processed in
deepest-to-shallowest, left-to-right order, and syncs are currently the only
expression operator which can cause an observable side-effect.

- No longer fails to include line number and position when reporting errors
with parameter definitions.

- Functions inside a module no longer refer to the module as "self"; instead
they refer to it using the module's name, derived from its file name, just as
other files which import that module would do.

- Set object in the library no longer returns an exception when you try to add
an element: that is, the set object will now actualy work as a set container.

- The scanner no longer accepts linebreak characters inside a string literal:
that is now an error, as it should have been all along.


# 0.4.0 - 25 July 2012

- Yield statement works inside while-loops.

- No longer fails an assertion when a program defines two different functions
with the same name in the same scope; instead reports an appropriate error.

- Validation suite works again; check.sh or 'make check' runs all tests.

- New 'relation' module includes 'greater', 'less', and 'equal' relations and
functions which determine whether a given relation is_greater, is_less,
is_equal, is_greater_or_equal, is_less_or_equal, or is_not_equal. Relations are
the values returned by 'compare' functions such as sequence.compare.

- string.join function concatenates a sequence of strings into a single string;
string.join_with function inserts a delimiter between every pair of strings
in a sequence, returning a single string.

- Array methods which take index parameters no longer stop working after
reversing the array.

- New 'sync' operator turns the current function into an asynchronous task
generator; it yields its (optional) argument as the current response, then
returns the next value sent in by the caller. A statement form of 'sync' lets
you ignore the next value and just yield back a response. Response values
should be other asynchronous tasks.

- Object constructor parameters no longer become members of the result object;
they are just ordinary parameters now.

- Compiler reports an error when it finds a direct reference to an object
member - one that does not go through "self". Such references almost certainly
wouldn't do what you expect them to do, so they are now forbidden.

- string.from_sequence function accepts a sequence of characters and turns it
into a string object.

- Passing the wrong number of arguments to a function no longer produces an
undefined result; it will now raise an exception.

- Command-line --dumptokens switch has been replaced with --dump option:
supported output types are 'tokens', 'flowgraph', and 'lic'.


# 0.3.1 - 21 June 2012

- No longer mistakenly refers to libffi.dylib; links it in as a static library
instead, as it was supposed to do all along.


# 0.3.0 - 21 June 2012

- Objects offer prototypal inheritance through an optional 'from exp' clause
which follows the parameter list. The new object extends the prototype object;
any new members defined with the same names as members of the original object
will replace those original members. The source expression is evaluated inside
the object block context, and may refer to constructor parameters.

- Removed custom syntax for 'generator' and 'task' blocks. Generators are now
just functions which use a yield statement, and tasks are just functions which
use a yield expression. Keywords 'generator' and 'task' are no longer reserved.

- New 'stack' module in standard library specifies a stack type and provides a
blank stack object. Stack interface includes push, pop, and head; the stack
object also provides empty? and size functions.

- Map object has a new 'contains' method which accepts a key parameter and
returns true if the map contains the key, false if it does not.

- Sequence module offers a generic 'compare' method which returns an ordering
predicate describing the relationship between two sequences. This works for any
two sequences whose elements are comparable.

- One scope can now refer to only one definition of a given name. If a scope
refers to a context symbol with a certain name, it can no longer define a new
symbol of its own using the same name. The scope can still use any name it
likes for its symbols, as long as it does not also try to use a symbol of the
same name from some containing scope.


# 0.2.0 - 20 May 2012

- Sequence module has a new 'concatenate' method which joins two sequences.

- Number module has an 'absolute' function which flips the sign of any negative
number, leaving positive and zero numbers unchanged.

- Fixed implementation of number.truncate, which was failing to factor out the
denominator and basically only worked by accident.

- Fixed precedence of unary operators again: I tightened them too far and they
were binding more tightly than the member-lookup operator. No more.

- Inside a generator, vars declared before a yield statement no longer become 
read-only after it.

- Decimal literals can now be non-integral, using a decimal point.

- Symbols beginning with an underscore character are now inaccessible outside
the module which declared them, and are thus private by mechanism and not just
by convention. This affects both identifiers and symbol literals.

- Map objects have a 'size' function returning the number of contained pairs.

- Destructuring assignment for tuples: you can assign values from a sequence to
a comma-separated array of variables. Values are retrieved from the sequence in
order, assigned to the variables from left to right.

- Destructuring assignment for lists: you can assign values from a list to
a comma-separated array of variables which is contained in square brackets.
Values are retrieved from the list in densely packed ascending order starting
from index zero and are then assigned to the variables from left to right.

- Destructuring assignment is recursive: an element of an assignment target may
itself be a parenthesized sub-target (for a tuple) or a list assignment.


# 0.1.1 - 1 February 2012

- Removed debug spew when inserting or doing lookups on a map object. 

- String literal comparison no longer returns spurious "false" results when
comparing two equal strings.


# 0.1.0 - 31 January 2012

- A string is a sequence of characters, not a sequence of bytes. When iterating
over the characters in a string literal, the contents are no longer returned as
individual UTF-8 bytes, but as Unicode code points. 

- Symbol lookup time is now O(log n) in the worst case, not O(n), since the 
index is now an AA-tree rather than an unbalanced binary tree.

- A race condition in the symbol allocator has been corrected; it is no longer
possible to get duplicate symbols when the first lookup happens simultaneously
on different processors.

- io.print function emits UTF-8 byte streams instead of mangling non-ASCII
characters.

- The identifiers 'task', 'generator', and 'yield' have been reserved for
use as syntax keywords.

- String literals implement a compare_to method, which allows them to be
compared and used as keys in a map container. This method uses a simple ordinal
comparison, not one of the specific Unicode-defined lexical comparisons.

- Import statement allows an optional aliasing clause, where the local symbol
has a different name than the target module. The syntax is now this:
	'import' identifier ['=' identifier] ['from' expression]
As with all declarations, the first identifier token is the declared name; the
optional second identifier specifies the target to import. 

- Expressions can now be split and continued on the next line after any binop
token, including the comma and period tokens. Comments between a binop token
and the end of line will be ignored.

- Tuples implement the sequence interface.

- Map constructor no longer tries to double up as a set constructor. Entries
must have both a key and a value.

- Unary operators (negate, not, poison, and yield) no longer parse an entire
expression instead of a single term. This caused baffling precedence errors.

- Numerics package supports rational as well as integer arithmetic. Rational
numbers are represented as a pair of integers, numerator and denominator.
Rational numbers are normalized such that the numerator and denominator have no
common factors and the denominator is always positive and greater than 1. 
Division of two integers will now yield a rational number instead of truncating
the remainder and returning an integer. Number type has two new predicates:
rational?, which is currently true for all numbers, and integer?, which is true
only for integral values. The shifting and bit-arithmetic operations are only
defined for integers, not for all rationals.

- Functions in the number module allow rounding of rational numbers in three
modes: ceiling rounds to the nearest integer toward positive infinity, floor
rounds to the nearest integer toward negative infinity, and truncate rounds
to the nearest integer toward zero.

- Sign function in the number module returns -1 for negative numbers, 1 for
positive numbers, and 0 for all numbers which are equal to zero.

- New "generator" block type lets you define a function which returns a
sequence. The generator supplies each value in the sequence by executing a 
"yield" statement. This is not yet useful, as you cannot put yield statements 
inside nested loops or conditionals, but it is a sign of things to come.


# 0.0.0 - 30 December 2011

- First release.
