// Copyright 2013 Mars Saxman
//
// This software is provided 'as-is', without any express or implied warranty.
// In no event will the authors be held liable for any damages arising from the
// use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
// claim that you wrote the original software. If you use this software in a
// product, an acknowledgment in the product documentation would be appreciated
// but is not required.
//
// 2. Altered source versions must be plainly marked as such, and must not be
// misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.

#include "macros.h"
#include "floats.h"
#include "symbols.h"
#include "booleans.h"
#include "numbers.h"
#include "fixints.h"
#include "bigints.h"
#include "rationals.h"
#include "relations.h"
#include "buffer.h"
#include <assert.h>
#include <math.h>

// The floating point number is based on the built in IEE754 double type.
// The object is a buffer, sizeof(double). It is designed for approximate
// computations on real numbers. It is a contagious type; floats can be used
// in computations with integers and rationals, but the result will be a float,
// unless one specifically rounds to an integer.

static value_t Float_function( PREFUNC, value_t selector );

static double DoubleFromInt( value_t exp )
{
	if (IsAFixint( exp )) {
		return (double)IntFromFixint( exp );
	} else {
		return DoubleFromBigint( exp );
	}
}

#define STANDARD_CRACK \
	ARGCHECK_2(left, right); \
	double lval = *BUFDATA( left, double ); \
	double rval = 0.0; \
	if (IsAFixint( right )) { \
		rval = (double)IntFromFixint( right ); \
	} else if (IsABigint( right )) { \
		rval = DoubleFromBigint( right ); \
	} else if (IsARational( right )) { \
		rval = DoubleFromInt( METHOD_0( right, sym_numerator ) ); \
		rval /= DoubleFromInt( METHOD_0( right, sym_denominator ) ); \
	} else if (IsAFloat( right )) { \
		rval = *BUFDATA( right, double ); \
	} else return NaNExp( zone, right )

static value_t Float_compare_to( PREFUNC, value_t left, value_t right )
{
	STANDARD_CRACK;
	return RelationFromDouble( lval - rval );
}

static value_t Float_add( PREFUNC, value_t left, value_t right )
{
	STANDARD_CRACK;
	return NumberFromDouble( zone, lval + rval );
}

static value_t Float_subtract( PREFUNC, value_t left, value_t right )
{
	STANDARD_CRACK;
	return NumberFromDouble( zone, lval - rval );
}

static value_t Float_multiply( PREFUNC, value_t left, value_t right )
{
	STANDARD_CRACK;
	return NumberFromDouble( zone, lval * rval );
}

static value_t Float_divide( PREFUNC, value_t left, value_t right )
{
	STANDARD_CRACK;
	return NumberFromDouble( zone, lval / rval );
}

static value_t Float_modulus( PREFUNC, value_t left, value_t right )
{
	STANDARD_CRACK;
	return NumberFromDouble( zone, fmod( lval, rval ) );
}

static value_t Float_exponentiate( PREFUNC, value_t left, value_t right )
{
	STANDARD_CRACK;
	return NumberFromDouble( zone, pow( lval, rval ) );
}

static value_t Float_function( PREFUNC, value_t selector )
{
	ARGCHECK_1( selector );
	DEFINE_METHOD( compare_to, Float_compare_to )
	DEFINE_METHOD( add, Float_add )
	DEFINE_METHOD( subtract, Float_subtract )
	DEFINE_METHOD( multiply, Float_multiply )
	DEFINE_METHOD( divide, Float_divide )
	DEFINE_METHOD( modulus, Float_modulus )
	DEFINE_METHOD( exponentiate, Float_exponentiate )
	if (selector == sym_is_number) return &True_returner;
	if (selector == sym_is_rational) return &False_returner;
	if (selector == sym_is_integer) return &False_returner;
	return ThrowMemberNotFound( zone, selector );
}

// This function is used inside the runtime but it is also an entry point for
// code generated by the backend.
value_t NumberFromDouble( zone_t zone, double data )
{
	return (value_t)clone_buffer(
		zone,
		(function_t)Float_function,
		sizeof(double),
		&data );
}

double DoubleFromFloat( value_t exp )
{
	assert( IsAFloat( exp ) );
	return *BUFDATA(exp, double);
}

bool IsAFloat( value_t exp )
{
	return exp && exp->function == (function_t)Float_function;
}

value_t FloatConvertRational( zone_t zone, value_t numer, value_t denom )
{
	double fnumer = IntFromFixint( numer );
	double fdenom = IntFromFixint( denom );
	return NumberFromDouble( zone, fnumer / fdenom );
}


