Raffle syntax is made up of literals, symbols, delimiters, and operators.
A Raffle program uses these elements to describe the flow of data from one
operation to the next, starting with some implicit input value which will be
provided when the program is executed.

Whitespace is ignored except as it serves to mark the end of a token; any
number of spaces or tabs may occur between tokens. Comments begin with a hash
character '#' and continue up to the next newline. Blank lines and lines which
contain only comments are ignored.

Values may be primitive - integers, booleans, or byte buffers - but values may
also be complex structures built from nested tuples. Furthermore, the lambda
and capture operators create function references, which may be passed around
like any other value and invoked at any point later on.

Literals represent concrete values. A decimal literal begins with a digit from
[1-9] and may have any number of additional digits from [0-9]. A hex literal
begins with "0X" or "0x" and continues with one or more digits [0-9A-Fa-f].

A symbol represents an abstract value not yet computed; symbols begin with any
alphabetic character [A-Z] or [a-z], or an underscore '_'. A symbol may contain
any number of additional alphabetic characters, underscores, or digits [0-9].

Delimiters combine expressions into structures. Matched pairs of parentheses,
brackets, or braces wrap an arbitrarily complex subexpression into a single
element of the context expression. The opening and closing characters must
match, they must be strictly nested, and they may neither begin nor end with
an operator. Subexpressions may also be joined into a sequence, delimited by
comma characters; when evaluated, this yields a tuple object.

Operators join a preceding value to a following expression and combine them to
produce a new value, which may in turn act as the preceding value for another
operator. The operators are as follows:

	+	sum
	-	difference
	*	product
	/	quotient
	%	remainder
	&	and
	|	or
	^	xor
	<	less than
	=	equal to
	>	greater than
	!<	not less than
	!=	not equal to
	!>	not greater than
	;	sequence
	.	select
	->	lambda

TODO:
	subscripting
	parens: evaluate this
	brackets: define a set
	fail value, fail operations
	pattern matching using fail sets
	braces as macro capture, deferred evaluation...?
	figure out how to deal with symbols
	define function composition (do operators just... do the right thing?)
	aha: you talk about the "fail value" indirectly, by defining things that
	either return a real value or fail. so types are not predicate functions,
	they are *assertion* functions, which either return the input unchanged
	or "return void".
	then we just need a "fail-over" operator that conditionally evaluates the
	RHS expression if the LHS expression == fail; we could chain them together
	to build pattern matchers, and of course all kinds of simple logic
	and.... the way to construct such a system is to provide a literal which
	represents a set, and I think I'll use brackets for that
	[1, 2, 3] returns its input, whenever the input is 1, 2, or 3; otherwise,
	it returns void.
	how does that work with subscripting? well, subscripting is a selection
	operation; you're asking the object to suppy all members which belong to
	the specified set.
	then, we define the dot as a prefix which, when applied to a literal,
	means "the set containing only this value" - and then member lookup is
	literally nothing more than an ordinary method call
	this also gives us a way to talk about objects, because we can describe
	an object by providing a tuple listing its members
	I still think there's something to the idea of annotating symbols with
	type-predicates, or adapters, or something, but that's not baked yet.

